module Monitor;

export *;
import * from ABS.DC;
import * from MailGen;
import * from Architecture;
import * from Sys_init;
import * from Wrapper;
import * from DB;
import * from Scaler;
import * from Param;

interface MonitorInterface {}

class Monitor(ScalerServiceInterface scaler, DBInterface db, List<Int> init_conf) implements MonitorInterface {
  Int time = 0;
  List<Int> last_pred_config = init_conf; //field for proactive-reactive global scaling
  List<Rat> errors = list[]; //field for proactive-reactive global scaling
  //Rat last_pred = 32; //uncomment when using literature mixing method

  //////MIXING TECHNIQUE//////////
  List<Int> compute_diff(List<Int> pred_conf, List<Int> actual_conf) {
    List<Int> diff = list[];
    while(!isEmpty(pred_conf) && !isEmpty(actual_conf)) {
      diff = appendright(diff, head(pred_conf) - head(actual_conf));
      pred_conf = tail(pred_conf);
      actual_conf = tail(pred_conf);
    }
    return diff;
  }

 Rat compute_weight(List<Int> pred_conf, List<Int> actual_conf) {
    List<Rat> dev_factors = scaler.getScores();
    Rat curr_weight = 0;
    List<Int> diffs = this.compute_diff(pred_conf, actual_conf); 
    while(!isEmpty(pred_conf) && !isEmpty(actual_conf)) {
      curr_weight = curr_weight + abs(head(diffs) * head(dev_factors));
      pred_conf = tail(pred_conf);
      actual_conf = tail(pred_conf);
      diffs = tail(diffs);
      dev_factors = tail(dev_factors);
    }
    return min(curr_weight, 1);
  }

  Unit store_weights(Rat curr_weight) {
    errors = appendright(errors, abs(curr_weight));
    if(length(errors) == memory()) errors = tail(errors);
  }

  Rat compute_distance() {
    Rat weight = 0;
    Int toDivide = 0;
    foreach(e,i in errors) {
      weight = weight + e * (i + 1);
      toDivide = toDivide + (i + 1);
    }
    return weight / toDivide;
  }


  Rat mix(Rat max_true, Rat max_pred) {
    List<Int> actual_conf = scaler.computeConfiguration(max_true);
    Rat curr_weight = this.compute_weight(last_pred_config, actual_conf);
    this.store_weights(curr_weight);
    Rat react_score = this.compute_distance();
    Rat pred_score = 1 - react_score;
    Rat target_scale = (react_score * max_true) + (pred_score * max_pred);
    last_pred_config = scaler.computeConfiguration(max_pred);
    return target_scale;
  }

  //////END MIXING TECHNIQUE//////////


  ////MIXING TECHNIQUE TAKEN FROM THE LITERATURE////
 /*Rat compute_diff(Rat pred, Rat obs) {
    Rat diff = 0;
    Int j = 0;
    Int toDivide = 0;
    errors = appendright(errors, max(0, obs - pred));
    if(length(errors) == 3) errors = tail(errors);
    while(j < length(errors)) {
      diff = diff + nth(errors,j);
      toDivide = toDivide + 1;
      j = j + 1;
    }
    if(toDivide != 0) diff = diff / toDivide;
    return diff;
  }


  Rat mix(Rat max_true, Rat max_pred) {
    Rat diff = this.compute_diff(last_pred, max_true);
    last_pred = max_pred;
    Rat target_scale = max_pred + diff;
    return target_scale;
  }*/

  /////END MIXING TECHNIQUE TAKEN FROM THE LITERATURE////

  Pair<Rat,Rat> find_maxes() {
    Rat max_pred = -1;
    Rat max_true = -1;
    Int i = 0;
    while(i < ratio()) {
      await duration(monitoringWin()/ratio(), monitoringWin()/ratio());
      Rat chunk_pred = -1;
      if(proactiveness()) chunk_pred = nth(predicted_workload(), (i + time) % length(predicted_workload()));
      Rat chunk_real = db.get_one_sec_workload();
      db.one_sec_timeout();
      max_pred = max(chunk_pred,max_pred);
      max_true = max(chunk_real,max_true);
      i = i + 1;
    }
    return Pair(max_pred, max_true);
  }

	Unit run() {
    while(time < 200){
      Pair<Rat,Rat> maxes = this.find_maxes();
      Rat max_pred = fst(maxes);
      Rat max_true = snd(maxes);
      Rat target_workload = max_true;
      if(proactiveness()) target_workload = max_pred;
      if(mixing()) target_workload = this.mix(max_true, max_pred);
      time = time + ratio();
      Rat mcl = scaler.getSystemMCL();
      Int nInst = scaler.computeInstanceNumber();
      if(target_workload - (mcl - kbig()) > k() || (mcl - kbig()) - target_workload > k()) {
        List<Int> target_config = scaler.computeConfiguration(target_workload);
        scaler.scale(target_config);
      }
      this.log(max_true, max_pred, mcl, target_workload, nInst); //debug purpose
      db.resetMetrics();
    }
  }

  Unit log(Rat max_true, Rat max_pred, Rat mcl, Rat target, Int nInst) {
      Float averageAnalysisTime = db.returnAverageAnalysisTime();
      Rat completed = db.messageCompleted();
      Rat rejected = db.rejectedMessages();
      Rat totalMsg = db.get_inbound_workload();
      Rat totalCost = scaler.computeTotalCost(ratio());
      String toPrint = toString(time) + "  " + toString(float(100/3) * averageAnalysisTime);
      if(proactiveness()) toPrint = toPrint + " #next_max: " + toString(max_pred);
      toPrint = toPrint + " curr_max: " + toString(max_true); 
      if(mixing()) toPrint = toPrint + " target_scale: " + toString(float(target));
      toPrint = toPrint + " TOT: " + toString(totalMsg) + " COMP: " + toString(completed) + " REJ: " + toString(rejected) + " SUPP: " + toString(mcl) + " COST: " + toString(float(totalCost)) + " INST: " + toString(nInst);
      String scalingAct = scaler.getScalingActions();
      toPrint = toPrint + scalingAct;
      println(toPrint);
  }
}

